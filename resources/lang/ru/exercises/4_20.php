<?php

return [
    'title' => 'Особая форма letrec',
    'description' => [
        '1' => "Поскольку внутренние определения выглядят последовательными, а на самом деле параллельны, " .
        "некоторые предпочитают их вовсе избегать и вместо этого пользуются особой формой letrec. " .
        "Letrec выглядит так же, как let, поэтому неудивительно, что переменные в нем связываются " .
        "одновременно и имеют одинаковую для всех сферу действия. Можно переписать процедуру-пример " .
        "f из текста без внутренних определений, но при этом в точности с тем же значением, так:",
        '2' => "Выражение letrec имеет вид",
        '3' => "и является вариантом let, в котором выражения <вырk>, устанавливающие начальные значения " .
        "для переменных <перk>, вычисляются в окружении, которое включает все связывания letrec. Это " .
        "делает возможным рекурсию между связываниями, к примеру, взаимную рекурсию even? и odd? в " .
        "последнем примере, или вычисление факториала 10 через",
        '4' => "а. Реализуйте letrec как производное выражение, переводя выражение letrec в выражение " .
        "let, как показано в тексте раздела или в упражнении ",
        '5' => ". То есть переменные letrec должны создаваться в let, а затем получать значение через set!.",
        '6' => "б. Хьюго Дум совсем запутался во всех этих внутренних определениях. Ему кажется, что " .
        "если кому-то не нравятся define внутри процедуры, то пусть пользуются обычным let. Покажите, " .
        "что в его рассуждениях неверно. Нарисуйте диаграмму, показывающую окружение, в котором " .
        "выполняется <остаток тела f> во время вычисления выражения (f 5), если f определена как в этом " .
        "упражнении. Нарисуйте диаграмму окружений для того же вычисления, но только с let на месте " .
        "letrec в определении f.",
    ],
];
